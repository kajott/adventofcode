# 2024, Day 22: Monkey Market

As you're all teleported deep into the jungle, a [monkey](../../2022/11) steals The Historians' device! You'll need to get it back while The Historians are looking for the Chief.

The monkey that stole the device seems willing to trade it, but only in exchange for an absurd number of bananas. Your only option is to buy bananas on the Monkey Exchange Market.

You aren't sure how the Monkey Exchange Market works, but one of The Historians senses trouble and comes over to help. Apparently, they've been studying these monkeys for a while and have deciphered their secrets.

Today, the Market is full of monkeys buying _good hiding spots_. Fortunately, because of the time you recently spent in this jungle, you know lots of good hiding spots you can sell! If you sell enough hiding spots, you should be able to get enough bananas to buy the device back.

On the Market, the buyers seem to use random prices, but their prices are actually only [pseudorandom](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)! If you know the secret of how they pick their prices, you can wait for the perfect time to sell.

The part about secrets is literal, the Historian explains. Each buyer produces a pseudorandom sequence of secret numbers where each secret is derived from the previous.

## Part 1

In particular, each buyer's _secret_ number evolves into the next secret number in the sequence via the following process:

*   Calculate the result of _multiplying the secret number by `64`_. Then, _mix_ this result into the secret number. Finally, _prune_ the secret number.
*   Calculate the result of _dividing the secret number by `32`_. Round the result down to the nearest integer. Then, _mix_ this result into the secret number. Finally, _prune_ the secret number.
*   Calculate the result of _multiplying the secret number by `2048`_. Then, _mix_ this result into the secret number. Finally, _prune_ the secret number.

Each step of the above process involves _mixing_ and _pruning_:

*   To _mix_ a value into the secret number, calculate the [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR) of the given value and the secret number. Then, the secret number becomes the result of that operation. (If the secret number is `42` and you were to _mix_ `15` into the secret number, the secret number would become `37`.)
*   To _prune_ the secret number, calculate the value of the secret number [modulo](https://en.wikipedia.org/wiki/Modulo) `16777216`. Then, the secret number becomes the result of that operation. (If the secret number is `100000000` and you were to _prune_ the secret number, the secret number would become `16113920`.)

After this process completes, the buyer is left with the next secret number in the sequence. The buyer can repeat this process as many times as necessary to produce more secret numbers.

So, if a buyer had a secret number of `123`, that buyer's next ten secret numbers would be:

    15887950
    16495136
    527345
    704524
    1553684
    12683156
    11100544
    12249484
    7753432
    5908254

Each buyer uses their own secret number when choosing their price, so it's important to be able to predict the sequence of secret numbers for each buyer. Fortunately, the Historian's research has uncovered the _initial secret number of each buyer_ (your puzzle input). For example:

    1
    10
    100
    2024

This list describes the _initial secret number_ of four different secret-hiding-spot-buyers on the Monkey Exchange Market. If you can simulate secret numbers from each buyer, you'll be able to predict all of their future prices.

In a single day, buyers each have time to generate `2000` _new_ secret numbers. In this example, for each buyer, their initial secret number and the 2000th new secret number they would generate are:

    1: 8685429
    10: 4700978
    100: 15273692
    2024: 8667524

Adding up the 2000th new secret number for each buyer produces _`37327623`_.

For each buyer, simulate the creation of 2000 new secret numbers. _What is the sum of the 2000th secret number generated by each buyer?_

Your puzzle answer was `20071921341`.

## Part 2

Of course, the secret numbers aren't the prices each buyer is offering! That would be ridiculous. Instead, the _prices_ the buyer offers are just the _ones digit_ of each of their secret numbers.

So, if a buyer starts with a secret number of `123`, that buyer's first ten _prices_ would be:

    3 (from 123)
    0 (from 15887950)
    6 (from 16495136)
    5 (etc.)
    4
    4
    6
    4
    4
    2

This price is the number of _bananas_ that buyer is offering in exchange for your information about a new hiding spot. However, you still don't speak [monkey](../../2022/21), so you can't negotiate with the buyers directly. The Historian speaks a little, but not enough to negotiate; instead, he can ask another monkey to negotiate on your behalf.

Unfortunately, the monkey only knows how to decide when to sell by looking at the _changes_ in price. Specifically, the monkey will only look for a specific sequence of _four consecutive changes_ in price, then immediately sell when it sees that sequence.

So, if a buyer starts with a secret number of `123`, that buyer's first ten secret numbers, prices, and the associated changes would be:

         123: 3 
    15887950: 0 (-3)
    16495136: 6 (6)
      527345: 5 (-1)
      704524: 4 (-1)
     1553684: 4 (0)
    12683156: 6 (2)
    11100544: 4 (-2)
    12249484: 4 (0)
     7753432: 2 (-2)

Note that the first price has no associated change because there was no previous price to compare it with.

In this short example, within just these first few prices, the highest price will be `6`, so it would be nice to give the monkey instructions that would make it sell at that time. The first `6` occurs after only two changes, so there's no way to instruct the monkey to sell then, but the second `6` occurs after the changes `-1,-1,0,2`. So, if you gave the monkey that sequence of changes, it would wait until the first time it sees that sequence and then immediately sell your hiding spot information at the current price, winning you `6` bananas.

Each buyer only wants to buy one hiding spot, so after the hiding spot is sold, the monkey will move on to the next buyer. If the monkey _never_ hears that sequence of price changes from a buyer, the monkey will never sell, and will instead just move on to the next buyer.

Worse, you can only give the monkey _a single sequence_ of four price changes to look for. You can't change the sequence between buyers.

You're going to need as many bananas as possible, so you'll need to _determine which sequence_ of four price changes will cause the monkey to get you the _most bananas overall_. Each buyer is going to generate `2000` secret numbers after their initial secret number, so, for each buyer, you'll have _`2000` price changes_ in which your sequence can occur.

Suppose the initial secret number of each buyer is:

    1
    2
    3
    2024

There are many sequences of four price changes you could tell the monkey, but for these four buyers, the sequence that will get you the most bananas is `-2,1,-1,3`. Using that sequence, the monkey will make the following sales:

*   For the buyer with an initial secret number of `1`, changes `-2,1,-1,3` first occur when the price is _`7`_.
*   For the buyer with initial secret `2`, changes `-2,1,-1,3` first occur when the price is _`7`_.
*   For the buyer with initial secret `3`, the change sequence `-2,1,-1,3` _does not occur_ in the first 2000 changes.
*   For the buyer starting with `2024`, changes `-2,1,-1,3` first occur when the price is _`9`_.

So, by asking the monkey to sell the first time each buyer's prices go down `2`, then up `1`, then down `1`, then up `3`, you would get _`23`_ (`7 + 7 + 9`) bananas!

Figure out the best sequence to tell the monkey so that by looking for that same sequence of changes in every buyer's future prices, you get the most bananas in total. _What is the most bananas you can get?_

Your puzzle answer was `2242`.

## Solution Notes

The most complex thing about this puzzle is understanding the task description. For starters, all those multiplications, divisions and modulos amount to simple shifts and ANDs, and the entire thing is just a 24-bit [XORshift](https://en.wikipedia.org/wiki/Xorshift) PRNG. Part 1 is just about implementing that and letting it run for ~4 million iterations (~2k input lines x 2k iterations per line). CPython is surprisingly slow at this and there's nothing that can be done to optimize it further; just using PyPy gives the answer in a fraction of a second.

Part 2 boils down to observing the previous 4 values modulo 10 and their deltas while perfoming the 2k PRNG iterations per line. Each time a sequence of 4 deltas occurs for the first time for an input line, the current value (modulo 10) can be added to the achievable score for that delta sequence. After all the input lines have been processed, the highest such score across all sequences is the result.

Due to all the dictionary manipulation involved, part 2 is no longer significantly faster on PyPy than on CPython. But how fast could it be? Out of curiosity, I implemented a C version of this puzzle, using a flat zero-initialized list instead of hash maps for the central data structure. After all, there are just 19^4 = ~130k possible sequences of four deltas, and not even all of these are valid (9,9,9,9, for example, isn't), so the entire thing fits comfortably into a modern CPU's cache. There only need to be two data items per entry: The resulting score, and some kind of flag to note whether this delta sequence has already been encountered for the current line. Since I didn't want to waste any time on clearing this flag, I opted for a line counter instead: An entry is only updated if it hasn't been updated already for the current input line. The solution is even relatively nicely golfable, coming in at well below 500 bytes, and it executes practically instantaneously, even if the compile time is included.

* Part 1, Python: 120 bytes, ~2.5 s
* Part 2, Python: 238 bytes, ~10 s
* Parts 1+2, C: 451 bytes, ~150 ms
